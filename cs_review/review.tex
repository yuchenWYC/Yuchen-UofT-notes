% Autogenerated translation of review.md by Texpad
% To stop this file being overwritten during the typeset process, please move or remove this header

\documentclass[12pt]{book}
\usepackage{graphicx}
\usepackage{fontspec}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,left=.5in,right=.5in,top=.3in,bottom=0.3in]{geometry}
\setlength\parindent{0pt}
\setlength{\parskip}{\baselineskip}
\setmainfont{Helvetica Neue}
\usepackage{hyperref}
\pagestyle{plain}
\begin{document}

\chapter*{Backend Development Basics Review}

\chapter*{Python functions}

\subsection*{Ceiling Function}

\begin{verbatim}
Math.ceil(p / K) = ((p-1) // K) + 1
\end{verbatim}

\subsection*{Sort key-value pairs first by values then keys}

\begin{verbatim}
# my_list: a list of key-value pair tuples
for key, value in sorted(my_list, key=lambda x:(x[1], x[0])):
    res.append(key + " " + value)
\end{verbatim}

\subsection*{Dictionary functions}

\texttt{$<$img style="width:100\%; text-align: center;" src="python\_dict.png"/$>$}

\subsection*{bisect (binary search)}

\begin{verbatim}
bisect.bisect_left(a, x, lo=0, hi=len(a))
\end{verbatim}

Locate the insertion point for x in a to maintain sorted order. The parameters lo and hi may be used to specify a subset of the list which should be considered; by default the entire list is used. If x is already present in a, the insertion point will be before (to the left of) any existing entries. The return value is suitable for use as the first parameter to list.insert() assuming that a is already sorted.

The returned insertion point i partitions the array a into two halves so that all(val $<$ x for val in a[lo:i]) for the left side and all(val $>$= x for val in a[i:hi]) for the right side.

\section*{Special Python functions and values}

\subsection*{str.split()}

By default, split the str by any white spaces.

\subsection*{str.strip()}

Remove spaces at the beginning and at the end of the string.

\subsection*{list.sort()}

Sort the list in-place in ascending order.

\subsection*{float('-inf') / float('inf')}

\subsection*{list(\#a string)}

Split a string into arrays with elements separated as items.

\subsection*{collections.OrderedDict()}

\subsection*{key in dict}

syntax to check if the dictionary dict contains the key.

\section*{Python set}

Python set is implemented as a \textbf{hash table} with just keys and no values. The key is passed into a hash function, which returns a block address or index. The average time complexity of lookup / insert / delete is O(1).

\chapter*{Algorithms}

\section*{Union-Find (Rank and Path Compression) O(n)}

\begin{verbatim}
def find(parent, i):
  if parent[i] != i:
    parent[i] = find(parent, parent[i])
  return parent[i]

def union(rank, x, y):
x, y = find(x), find(y)
  if rank[x] > rank[y]:
    parent[y] = x
  elif rank[y] > rank[x]:
    parent[x] = y
  else:
    parent[y] = x
    rank[x] += 1

parent = [i for i in range(n)]
rank = [0] * n
for (i, j) in ...:
    m = find(parent, i)
    n = find(parent, j)
    if m != n:
      union(rank, m, n)
\end{verbatim}

\section*{Binary Search}

\begin{verbatim}
function binary_search(A, n, T) is
    L := 0
    R := n − 1
    while L ≤ R do
        m := floor((L + R) / 2)
        if A[m] < T then
            L := m + 1
        else if A[m] > T then
            R := m − 1
        else:
            return m
    return unsuccessful
\end{verbatim}

\section*{Binary Trees}

\subsubsection*{\textbf{In-order traversal}}

\begin{verbatim}
Algorithm Inorder(tree)
  1. Traverse the left subtree, i.e., call Inorder(left-subtree)
  2. Visit the root.
  3. Traverse the right subtree, i.e., call Inorder(right-subtree)
\end{verbatim}

\subsubsection*{\textbf{Pre-order traversal}}

\begin{verbatim}
Algorithm Preorder(tree)
  1. Visit the root.
  2. Traverse the left subtree, i.e., call Preorder(left-subtree)
  3. Traverse the right subtree, i.e., call Preorder(right-subtree) 
\end{verbatim}

\subsubsection*{\textbf{Post-order Traversal}}

\begin{verbatim}
Algorithm Postorder(tree)
  1. Traverse the left subtree, i.e., call Postorder(left-subtree)
  2. Traverse the right subtree, i.e., call Postorder(right-subtree)
  3. Visit the root.
\end{verbatim}

\section*{Minimum Spanning Trees}

\subsubsection*{\textbf{Prim Algorithm} O(ElogV)}

\begin{verbatim}
# Prim's Algorithm in Python

INF = 9999999
# number of vertices in graph
N = 5
#creating graph by adjacency matrix method
G = [[0, 19, 5, 0, 0],
    [19, 0, 5, 9, 2],
    [5, 5, 0, 1, 6],
    [0, 9, 1, 0, 1],
    [0, 2, 6, 1, 0]]

selected_node = [0, 0, 0, 0, 0]

no_edge = 0

selected_node[0] = True

# printing for edge and weight
print("Edge : Weight\n")
while (no_edge < N - 1):

    minimum = INF
    a = 0
    b = 0
    for m in range(N):
        if selected_node[m]:
            for n in range(N):
                if ((not selected_node[n]) and G[m][n]):  
                    # not in selected and there is an edge
                    if minimum > G[m][n]:
                        minimum = G[m][n]
                        a = m
                        b = n
    print(str(a) + "-" + str(b) + ":" + str(G[a][b]))
    selected_node[b] = True
    no_edge += 1
\end{verbatim}

\subsubsection*{\textbf{Kruskal Algorithm} O(V\textasciicircum{}2)}

Leverages Union-Find

\begin{verbatim}
KRUSKAL(G):
A = ∅
For each vertex v ∈ G.V:
    MAKE-SET(v)
For each edge (u, v) ∈ G.E ordered by increasing order by weight(u, v):
    if FIND-SET(u) ≠ FIND-SET(v):       
    A = A ∪ {(u, v)}
    UNION(u, v)
return A
\end{verbatim}

\section*{Depth-First Search O(V)}

Implemented using a stack.
class Graph:

\begin{verbatim}
def __init__(self,V): # Constructor
    self.V = V        # No. of vertices
    self.adj  = [[] for i in range(V)]  # adjacency lists

def addEdge(self,v, w):     # to add an edge to graph
    self.adj[v].append(w)    # Add w to v’s list.


# prints all not yet visited vertices reachable from s
def DFS(self,s):            # prints all vertices in DFS manner from a given source.
                            # Initially mark all verices as not visited
    visited = [False for i in range(self.V)]

    # Create a stack for DFS
    stack = []

    # Push the current source node.
    stack.append(s)

    while (len(stack)):
        # Pop a vertex from stack and print it
        s = stack[-1]
        stack.pop()

        # Stack may contain same vertex twice. So
        # we need to print the popped item only
        # if it is not visited.
        if (not visited[s]):
            print(s,end=' ')
            visited[s] = True

        # Get all adjacent vertices of the popped vertex s
        # If a adjacent has not been visited, then push it
        # to the stack.
        for node in self.adj[s]:
            if (not visited[node]):
                stack.append(node)
\end{verbatim}

\subsection*{DFS for binary trees (Recursion)}

\begin{verbatim}
def dfs(s: TreeNode, info):
  if not s:
    return # or return False
  # Some operations with s.val
  dfs(s.left, info)
  dfs(s.right, info)
\end{verbatim}

\subsection*{Notes}

\begin{enumerate}
\item Recursion is usually preferred because of cleaner code.
\item If an algorithm (e.g. topological sort) requires to mark verticies as black (explored), gray (visited) or white (unvisited), then we must write recursion instead of the while loop.
\item We can pass information from parents to children by leveraging parameters and return values.
\#\# Breadth-First Search O(V)
Implemented using a queue.
\end{enumerate}

\section*{Topological Sort O(V+E)}

\begin{enumerate}
\item Initialize a new array \emph{arr}.
\item For each of the unvisited nodes in our graph, we run \textbf{DFS}.
\item Suppose we are visiting node \emph{s}. After recursing on all of \emph{s}'s children, we add \emph{s} to \emph{arr} because all jobs that need \emph{s} as a prerequisite are already in \emph{arr}.
\item Once all the nodes have been processed, we simply return \emph{arr} in the reversed order. \\
\end{enumerate}

\section*{Dynamic Programming}

\subsection*{Outline}

\begin{itemize}
\item Breaking the problem down into simpler subproblems, solve each subproblem just once, and store their solutions.
\item The next time the same subproblem occurs, instead of recomputing its solution, simply look up its previously computed solution.
\item Hopefully, we save a lot of computation at the expense of modest increase in storage space.
\end{itemize}

\subsection*{Essential components}

\begin{enumerate}
\item DP table (stores the answer to the problem for a given state
\item Base cases (initialization values of the DP table)
\item Recurrence relationship
\end{enumerate}

\section*{Hash Table}

If let array elements be keys and array indices be values, we can reduce the lookup time from \$O(n)\$ to \$O(1)\$ by \textbf{trading space for speed}. 

Example: Leetcode \#1

\section*{QuickSort: \$O(nlogn)\$ average}

\section*{QuickSelect: \$O(n)\$ average}

Typically used to solve the problems "find \emph{k}th something": \emph{k}th smallest, \emph{k}th largest, \emph{k}th most frequent, \emph{k}th less frequent, etc. 

It has \$O(N)\$ average time complexity and \$O(N\textasciicircum{}2)\$ worst-case time complexity.

Note: the \emph{k}th largest element is the same as \emph{N-k}th smallest element.

\begin{verbatim}
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        def partition(left, right, pivot_index):
            pivot = nums[pivot_index]
            # 1. move pivot to end
            nums[pivot_index], nums[right] = nums[right], nums[pivot_index]
            # 2. move all smaller elements to the left
            store_index = left
            for i in range(left, right):
                if nums[i] < nums[right]:
                    nums[i], nums[store_index] = nums[store_index], nums[i]
                    store_index += 1

            # 3. move pivot to its final place
            nums[right], nums[store_index] = nums[store_index], nums[right]
            return store_index

        def select(left, right, k_smallest):
            # If the list contains only one element, return that element
            if left == right:
                return nums[left]
            # select a random index between left and right
            pivot_index = random.randint(left, right)
            # find the pivot position in a sorted list
            pivot_index = partition(left, right, pivot_index)
            # compare pivot_index with k
            if k_smallest == pivot_index:
                return nums[k_smallest]
            # go left
            elif k_smallest < pivot_index:
                return select(left, pivot_index - 1, k_smallest)
            else:
                return select(pivot_index + 1, right, k_smallest)
        # kth largest is (n-k)th smallest
        return select(0, len(nums) - 1, len(nums) - k)
\end{verbatim}

\chapter*{Operating Systems}

\textbf{x86} iis a family of instruction set architecture initially developed by Intel. 

\section*{Virtual Memory}

Each process in a multitaskiing OS runs in its own memory sandbox. This is the \textbf{virtual address space}, which in case of a 32-bit system is always a \textbf{4GB} block of memory addresses. 

Since the smallest unit addressable by the CPU is \textbf{1 byte = 8 bit}, it turns out that a 32-bit CPU is able to generate up to \$2\textasciicircum{}\{32\}\$ addresses. These virtual addresses are then mapped to real, physical memory addresses by \textbf{page tables} in \textbf{memory management unit (MMU)}, which are kept by the operating system kernel.

Since the OS kernel is a process itself, it has a dedicated portion of the virtual address space, separated from the portion reserved for any other user's application processes. 

The following picture shows a possible split between the OS kernel and the user mode virtual memory spaces on a typical 32-bit Linus OS.
\texttt{$<$img style="width:60\%; text-align: center;" src="https://gabrieletolomei.files.wordpress.com/2013/10/memory\_layout.jpg"/$>$}

\section*{How a process looks like within the user mode portion of the virtual address space}

\texttt{$<$img style="width:100\%; text-align: center;" src="https://gabrieletolomei.files.wordpress.com/2013/10/program\_in\_memory2.png"/$>$}

\subsubsection*{\textbf{Text (Code)}}

\begin{itemize}
\item Contains executable instructions of a program. 
\item Usually sharable, so that only a single copy needs to be in memory for frequently executed programs.
\item Often \emph{Read-only} or \emph{Executable}
\#\#\#\# \textbf{Data (Initialized data segment)}
\item Contains the \textbf{global} and \textbf{static} variables that are initialized by the programmer.
\item Not \emph{Read-only}, values of the variables can be altered at run time.
\item Further classified into 

\begin{itemize}
\item initialized \emph{Read-only} area. e.g. a string literal

const char* str = "hello world"
\item initialized \emph{Read-Write} area. e.g. the following C statements outside the main.

char s[] = "hello world"
int debug = 1

\subsubsection*{\textbf{BSS (Block Started by Symbol) /}  \textbf{Unitialized data segment}}
\end{itemize}
\item Data in this segment is initialized by the OS kernel of arithmetic 0 before the program starts executing.
\item \emph{Read-Write}
\item Contains all global and static variables initialzied to zero or not inialized in source code. e.g.

\begin{verbatim}
static int i
\end{verbatim}
\end{itemize}

\subsubsection*{\textbf{Stack}}

\begin{itemize}
\item Contains the program stack, an \textbf{LIFO} structure
\item (In x86) Grows downwards to lower addresses
\item Store all data needed by a function call in the program.
\item Specifically, the set of values pushed for one function call is named a \textbf{stack frame}. A \textbf{stack pointer} register tracks the top of the stack, and is adjusted each time a value is pushed onto the stack. If the stack pointer meets the \textbf{heap pointer}, the available free memory is exhausted.
\end{itemize}

\subsubsection*{Heap}

\begin{itemize}
\item Dynamic memory: memory requested by the programmer for variables whose size can be only known at run-time.
\item Managed by \texttt{$<$tt$>$} malloc\texttt{$<$/tt$>$} and \texttt{$<$tt$>$}free\texttt{$<$/tt$>$}, which may use the \texttt{$<$tt$>$}brk\texttt{$<$/tt$>$} and \texttt{$<$tt$>$}sbrk\texttt{$<$/tt$>$} system calls to adjust its size.
\end{itemize}

\subsection*{Physical Memory Hierarchy}

\texttt{$<$img style="width:80\%; text-align: center;" src="mem\_hierarchy.png"/$>$}

\section*{Processes and System Calls}

\begin{itemize}
\item A process contains all of the state for a program in execution.

\begin{itemize}
\item An \texttt{$<$span style="color:red"$>$} address space \texttt{$<$/span$>$}
\item The \texttt{$<$span style="color:red"$>$} code + data \texttt{$<$/span$>$} for the executing program
\item An execution \texttt{$<$span style="color:red"$>$} stack \texttt{$<$/span$>$} encapsulating the state of procedure calls
\item The \texttt{$<$span style="color:red"$>$} program counter (PC) \texttt{$<$/span$>$} indicating the next instruction
\item A set of general-purpose \texttt{$<$span style="color:red"$>$} registers \texttt{$<$/span$>$}with current values
\item A set of operating system resources
\item Open files, network connections, signals, etc.
\end{itemize}
\item A process is named using its  \texttt{$<$span style="color:red"$>$} process ID (PID) \texttt{$<$/span$>$} 
\end{itemize}

\texttt{$<$img style="width:40\%; text-align: center" src="https://media.geeksforgeeks.org/wp-content/uploads/process-table.jpg"/$>$}

\subsection*{Process life cycle}

\texttt{$<$img style="width:80\%; text-align: center" src="cycle.png"/$>$}

\texttt{$<$span style="color:red"$>$} context switch\texttt{$<$/span$>$}: switch the CPU to another process by
- saving the state of the old process
- loading the saved state for the new process

When can this happen?
- Process calls \texttt{$<$tt$>$} yield()\texttt{$<$/tt$>$} system call (voluntarily)
- Process makes other system call and is blocked
- Timer interrupt handler decides to switch processes

\subsection*{Process Creation}

A process is created by another process. Parent is the creator, child is created. In Linux, the parent is the \texttt{$<$tt$>$}PPID\texttt{$<$/tt$>$} field of the \texttt{$<$tt$>$}ps -f\texttt{$<$/tt$>$}.

The \texttt{$<$span style="color:red"$>$}init process (PID 1)\texttt{$<$/span$>$} creates the first process. The main task of the init process is to call \texttt{$<$tt$>$}wait()\texttt{$<$/tt$>$} in a loop which collects the terminaton status of any process that it has adopted.

\subsubsection*{fork(): process are created.}

\begin{itemize}
\item Creates and initializes a new PCB
\item Creates a new address space
\item Initializes the addresss space with a copy of the entire contents of the address space of the parent
\item Initializes the kernel resources to point to the resources used by parent (e.g. open files)
\item Places the PCB on the ready queue
\item Returns in two processes

\begin{itemize}
\item returns the child's PID to the parent, "0" to the child.
\end{itemize}
\end{itemize}

\subsubsection*{exec(): start a new program}

\begin{itemize}
\item Stops the current process
\item Loads program into the process's address space
\item Initializes hardware context and args for the new program
\item Places the PCB onto the ready queue
\end{itemize}

Note: \texttt{$<$span style="color:red"$>$}It does not create a new process.\texttt{$<$/span$>$}

\subsection*{Process Destruction}

\subsubsection*{exit(): a process voluntarily releases all resources}

But OS cannot discard everything immediately.
- Stopping a process requires context switch to another process
- Parent may be awaiting or asking for the return value

When a process exits,
- Address space is freed
- Files are closed
- Some OS data structures retain the process's exit state
- PID is retained
- The process is now a zombie until its parent collect its terminaton status.
  - If it does not have a parent, then it is cleaned up by the init process.

We call the child process an "orphan" when its parent terminates first. When a process becomes an orphan, it is "adopted" by the init process. 

\subsection*{System Calls}

Function calls that invokes the operating system.

\subsubsection*{Interrupts}

\begin{itemize}
\item \textbf{Hardware interrupt}: Interrupts signal CPU that a hardware device has an event that needs attention. e.g.

\begin{itemize}
\item timer interrupt
\item seg fault
\item divide by zero
\end{itemize}
\item \textbf{Software trap or exception}: Interrupts signal errors or requests for OS intervention. e.g. system call.

\begin{itemize}
\item Some instructions are \textbf{privileged instructions} which can only run in kernel mode.
\item On a "system call interrupt", the mode bit is switched to allow privileged instructions to occur.
\end{itemize}
\end{itemize}

\subsubsection*{mmap}

Creating shared memory regions.

\section*{Processes \& threads}

How do processes communicate?
- signals
- pipes
- sockets
- shared files
- shared memory (e.g. threading, semaphores)
- message queues

\subsection*{Thread}

A \textbf{thread} is a single control flow through a program. A program wth multiple control flows is \textbf{multithreaded}.
- \textbf{Kernel-level threads}: modern OSs have taken the execution aspect of a process and separated it out into a thread abstraction. All thread operations are implemented in the kernel and the OS schedules all of the threads in the system.
- \textbf{User-level threads}: Managed entirely by the run-time system
  - Small and fast: A thread is simply represented by a PC, registers, stack, and small thread control block (TCB).
  - Threads easily share code, heap and global variables.
  - Creating a new thread, switching between threads, and  synchronizing threads are done via procedure call, no kernel involvement.

\subsubsection*{Processes vs. threads}

\begin{itemize}
\item Processes are more heavy-weight than threads and have a higher startup/shutdown cost
\item Processes are safer and more secure (each process has its own address space)

\begin{itemize}
\item A thread crash takes down all other threads
\item A thread's buffer overrun creates security problem for all
\end{itemize}
\end{itemize}

\subsubsection*{POSIX Threads (pthreads)}

Standardized C language threads programming API.

\section*{Deadlocks}

\begin{itemize}
\item Root causes:

\begin{itemize}
\item Resources are finite
\item Hardware
\item Data
\item Synchronization objects
\item Processes wait if a resource they need is unavailable
\item Resources may be held by other waiting processes
\end{itemize}
\end{itemize}

\subsection*{Conditions for deadlock}

\begin{enumerate}
\item \textbf{Mutual exclusion}: Only one process may use a resource at a time.
\item \textbf{Hold and wait}: A process may hold allocated resources while awaiting assignment of others. 
\item \textbf{No preemption}: No resource can be forcibly removed from a process holding it.
\item \textbf{Circular wait}: A closed chain of processes exits, such that each process holds at least one resource needed by the next process in the chain.
\end{enumerate}

\subsection*{Deadlock Prevention}

Idea: Break one of the four conditions and deadlock cannot occur.

\chapter*{System Programming}

\subsection*{Signals}

A mechanism that allow a process or the operating system to interrupt a currently running process and notify it that an event has occured.

\subsubsection*{sigaction()}

Modify the signal table so that a new signal handling function is called instead of the default action.

Each signal is identified by a number between 1 and 31.

\subsection*{I/O}

\subsubsection*{pipe()}

Pipe is one type of communication mechanism that can be used to send data between related processes.
- Specified by an array of two file descriptors: stored in fd
      - One for reading data from the pipe: the 0th element fd[0]
      - One for writing data to the pipe: the 1th element fd[1]
- Unidirectional

When the program calls \texttt{$<$tt$>$} pipe()\texttt{$<$/tt$>$},
- The operating system creates the pipe data structures and opens two file descriptors on the pipe
- The pipe system call returns.

\subsubsection*{select()}

\begin{verbatim}
  int select(numfd, read_fds, write_fds, error_fds, timeout)
\end{verbatim}

Avoid the situation where parent waiting for an indefinite child while the other child has a lot to say.

Idea: the caller specifies a set of file descriptors to watch. The second parameter is the address of the set of descriptors from which the user wants to read. \texttt{$<$span style="color:red;"$>$} Select blocks until one of these file descriptors has data to be read or until the resource has been closed.\texttt{$<$/span$>$} In either case, the user is certain now that calling read on that file descriptor will not cause \texttt{$<$tt$>$} read()\texttt{$<$/tt$>$} to block. We will say that a file descriptor like this (with data or with a closed resource) is "ready".

\subsubsection*{socket()}

\begin{verbatim}
  int socket (int domain, int type, int protocol)
\end{verbatim}

Sockets are built on the TCP protocol to communicate between processes on two different machines.

\subsubsection*{epoll()}

\begin{verbatim}
  int epoll_create1(int flags);
  int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
  int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
\end{verbatim}

\texttt{$<$tt$>$} epoll()\texttt{$<$/tt$>$} is meant to replace \texttt{$<$tt$>$}select()\texttt{$<$/tt$>$} and \texttt{$<$tt$>$} poll()\texttt{$<$/tt$>$} for a scalable I/O event notification mechanism. It monitors multiple file descriptors to see if I/O is possible on any of them.

\paragraph*{epoll() vs. select()}

\begin{itemize}
\item We can add and remove file descriptor while waiting.
\item \texttt{$<$tt$>$} epoll\_wait()\texttt{$<$/tt$>$} returns only the objects with ready file descriptors.
\item epoll has better performance – O(1) instead of O(n).
\end{itemize}

\subsubsection*{assert()}

void assert( int expression );
If expression evaluates to 0 (false), then the expression, sourcecode filename, and line number are sent to the standard error, and then \texttt{$<$tt$>$}abort()\texttt{$<$/tt$>$} function is called.

\texttt{$<$tt$>$} abort()\texttt{$<$/tt$>$} terminates the process by raising a SIGABRT signal.

\chapter*{Computer Networks}

\section*{TCP}

\subsection*{Three-way handshake}

\begin{enumerate}
\item Host A send a SYN to the host B

\begin{enumerate}
\item SYN=1, sequence number=x
\end{enumerate}
\item Host B returns a SYN acknowledgement (SYN ACK)

\begin{enumerate}
\item SYN=1, ACK=1, sequence number=x, ACKnum=x+1
\end{enumerate}
\item Host A sends an ACK to acknowledge SYN ACK

\begin{enumerate}
\item SYN=0, ACK=1, ACKnum=y+1
\end{enumerate}
\end{enumerate}

\texttt{$<$img style="width:100\%; text-align: center;" src="https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-made-three-way-handshake.png"/$>$}

\subsection*{Four-way handshake}

Tearing down TCP connections.
1. Host A send a FIN to the host B, indicating it has no packets to send out but can still receive data.
   1. FIN=1, sequence number=x
2. Host B returns an ACK. When A receive the packet, A will wait for B to close the connection.
   1. ACK=1, ACKnum=x+1
3. Host B sends a FIN to the host A to request closing the connection and wait for acknowledgment. B can no longer send data.
   1. FIN=1, seq=y
4. Host A sends an ACK to the host B
   1. ACK=1, ACKnum=y+1

\texttt{$<$img style="width:100\%; text-align: center;" src="https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-closed-four-way-handshake.png"/$>$}

\subsection*{Flow control}

Flow control
- The receiver specifies the \emph{receive window} field that it is willing to buffer for the connection. 
- When receiver advertises a window size of 0, the sender stops sending data and starts the \emph{persist timer}. When the timer expires, the sender attempts recovery by sending a small packet so that the receiver responds by sending another acknowledgement containing the new window size.

\subsection*{Congestion Control}

\begin{itemize}
\item Slow start

\begin{itemize}
\item Exponential Growth: increase window size one segment each time an ACK is received.
\end{itemize}
\item Congestion avoidance mechanism

\begin{itemize}
\item Additively increase the window size when successfully send a window of data.
\end{itemize}
\item Fast recovery algorithm

\begin{itemize}
\item Used for decreasing the window size upon packet loss.
\end{itemize}
\end{itemize}

\subsection*{UDP}

\begin{itemize}
\item Unreliable message delivery service
\item Lightweight communication between processes
\item No delay for connection establishment
\item No connection
\item Small packet header overhead (8 bytes)
\end{itemize}

Applications: telephone calls, video conferencing, gaming.

\section*{Hypertext Transfer Protocol (HTTP)}

An application layer (TCP/IP based) client-server protocol that allows web-based applications to communicate and exchange data.

\begin{itemize}
\item Connectionless
\item Stateless
\item Can deliver any sort of data
\end{itemize}

\subsection*{Hypertext Transfer Protocol Secure (HTTPS)}

An extention of HTTP. It is used for secure communication over a computer network, and is encripited using Transport Layer Security (TLS) or, formerly, Secure Sockets Layer (SSL). It forbids the intermediate nodes on the network to see the data in delivery.

\subsection*{Encryption of HTTPS}

Involves both symmetric and asymmetric encryption.

\subsubsection*{Handshake mechanism}

\begin{itemize}
\item The client sends out a request to the server.
\item The server generates a public key and a private key for asymmetric encrytion. It sends out the public key to the server along with a public certificate signed by the certification authority.
\item The client uses certificate to verify the public key belongs to the server. The client then generates the symmetric key for symmetric encryption, encrypts this key using the public key.
\item The server then decrypts the message using its private key.
\item The client and the server can then communicate safely using the symmetric key.
\end{itemize}

Requires a trusted Certification Authority (CA) to verify server's identity (signed with CA's private key). Client can verify certificate (and thus server identity) using CA's public key.

\chapter*{C++}

\section*{Virtual function}

A \textbf{virtual function} is a member function in the base class that we expect to redefine in derived classes. It ensures that the function is overriden.

\section*{Constructor}

A \textbf{constructor} in C++ is a special method that is automatically called when an object of class is created. 

When declared inside the class, the constructor can be defined ouside the class by specifying the name of the class followed by the scope resolution \texttt{$<$tt$>$}::\texttt{$<$/tt$>$}.

\begin{verbatim}
  class Car {        // The class
    public:          // Access specifier
        string brand;  // Attribute
        string model;  // Attribute
        int year;      // Attribute
        Car(string x, string y, int z); // Constructor declaration
  };

  // Constructor definition outside the class
  Car::Car(string x, string y, int z) {
        brand = x;
        model = y;
        year = z;
  }

  int main() {
        // Create Car objects and call the constructor with different values
        Car carObj1("BMW", "X5", 1999);
        Car carObj2("Ford", "Mustang", 1969);

        // Print values
        cout << carObj1.brand << " " << carObj1.model << " " << carObj1.year << "\n";
        cout << carObj2.brand << " " << carObj2.model << " " << carObj2.year << "\n";
        return 0;
  }
\end{verbatim}

\end{document}
